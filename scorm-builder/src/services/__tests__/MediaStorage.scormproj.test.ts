import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { FileStorage } from '../FileStorage'
import { MediaService } from '../MediaService'

// Mock Tauri's invoke function
const mockInvoke = vi.fn()
vi.mock('@tauri-apps/api/core', () => ({
  invoke: (cmd: string, args?: any) => mockInvoke(cmd, args)
}))

describe('MediaStorage - .scormproj path handling', () => {
  let fileStorage: FileStorage
  let mediaService: MediaService
  const projectId = '1234567890'
  const scormProjPath = `C:\\Projects\\TestProject_${projectId}.scormproj`
  
  beforeEach(() => {
    fileStorage = new FileStorage()
    // Set the current project path and ID for FileStorage
    fileStorage['_currentProjectPath'] = scormProjPath
    fileStorage['_currentProjectId'] = projectId
    
    mediaService = MediaService.getInstance({
      projectId: scormProjPath, // Pass .scormproj path instead of just ID
      fileStorage: fileStorage
    })
    mockInvoke.mockClear()
  })

  afterEach(() => {
    vi.clearAllMocks()
  })

  describe('Media operations with .scormproj paths', () => {
    it('should store media when projectId is a .scormproj path', async () => {
      const mediaId = 'media-123'
      const mediaFile = new File(['test'], 'image.jpg', { type: 'image/jpeg' })
      
      mockInvoke.mockImplementation((cmd, args) => {
        if (cmd === 'store_media_base64') {
          // Should extract the project ID from the .scormproj path
          expect(args.projectId).toBe(scormProjPath)
          return Promise.resolve()
        }
        if (cmd === 'store_media') {
          expect(args.projectId).toBe(scormProjPath)
          return Promise.resolve({
            id: mediaId,
            path: `media/${projectId}/image.jpg`,
            size: 1000
          })
        }
        return Promise.resolve(undefined)
      })
      
      const result = await mediaService.storeMedia(
        mediaFile,
        'page1',
        'image',
        { title: 'Test Image' }
      )
      
      expect(result).toBeDefined()
      // ID is generated by idGenerator which uses counters
      expect(result.id).toMatch(/^image-\d+$/)
      expect(mockInvoke).toHaveBeenCalledWith('store_media_base64', expect.objectContaining({
        projectId: scormProjPath
      }))
    })

    it('should delete media when projectId is a .scormproj path', async () => {
      const mediaId = 'media-123'
      
      mockInvoke.mockImplementation((cmd, args) => {
        if (cmd === 'delete_media') {
          // Backend should handle .scormproj path correctly
          expect(args.projectId).toBe(scormProjPath)
          expect(args.mediaId).toBe(mediaId)
          return Promise.resolve()
        }
        return Promise.resolve(undefined)
      })
      
      fileStorage['_currentProjectPath'] = scormProjPath
      const result = await fileStorage.deleteMedia(mediaId)
      
      expect(result).toBe(true)
      expect(mockInvoke).toHaveBeenCalledWith('delete_media', {
        projectId: scormProjPath,
        mediaId: mediaId
      })
    })

    it('should get media when projectId is a .scormproj path', async () => {
      const mediaId = 'media-123'
      const mediaData = new ArrayBuffer(100)
      
      mockInvoke.mockImplementation((cmd, args) => {
        if (cmd === 'get_media') {
          // Backend should handle .scormproj path correctly
          expect(args.projectId).toBe(scormProjPath)
          expect(args.mediaId).toBe(mediaId)
          return Promise.resolve({
            data: mediaData,
            mediaType: 'image',
            metadata: { pageId: 'page1' }
          })
        }
        return Promise.resolve(undefined)
      })
      
      fileStorage['_currentProjectPath'] = scormProjPath
      const result = await mediaService.getMedia(mediaId)
      
      expect(result).toBeDefined()
      expect(mockInvoke).toHaveBeenCalledWith('get_media', {
        projectId: scormProjPath,
        mediaId: mediaId
      })
    })

  })

  describe('Project ID extraction', () => {
    it('should handle various .scormproj filename formats', async () => {
      const testCases = [
        {
          path: 'TestProject_1234567890.scormproj',
          expectedId: '1234567890'
        },
        {
          path: 'C:\\Projects\\MyProject_9876543210.scormproj',
          expectedId: '9876543210'
        },
        {
          path: '/home/user/1234567890.scormproj',
          expectedId: '1234567890'
        }
      ]
      
      for (const testCase of testCases) {
        mockInvoke.mockClear()
        mockInvoke.mockResolvedValue(undefined)
        
        fileStorage['_currentProjectPath'] = testCase.path
        fileStorage['_currentProjectId'] = testCase.expectedId
        
        // Try to use the path in an operation
        await fileStorage.deleteMedia('test-media')
        
        // Verify the backend received the full path (backend will extract ID)
        expect(mockInvoke).toHaveBeenCalledWith('delete_media', {
          projectId: testCase.path,
          mediaId: 'test-media'
        })
      }
    })

    it('should work with plain project IDs as well', async () => {
      const plainId = '1234567890'
      
      mockInvoke.mockImplementation((cmd, args) => {
        if (cmd === 'delete_media') {
          expect(args.projectId).toBe(plainId)
          return Promise.resolve()
        }
        return Promise.resolve(undefined)
      })
      
      fileStorage['_currentProjectPath'] = plainId
      fileStorage['_currentProjectId'] = plainId
      await fileStorage.deleteMedia('test-media')
      
      expect(mockInvoke).toHaveBeenCalledWith('delete_media', {
        projectId: plainId,
        mediaId: 'test-media'
      })
    })
  })

  describe('Error handling', () => {
    it('should handle errors when backend fails to extract project ID', async () => {
      const invalidPath = 'NotAValidProject.scormproj'
      
      mockInvoke.mockImplementation((cmd) => {
        if (cmd === 'delete_media') {
          return Promise.reject(new Error('Invalid project ID format'))
        }
        return Promise.resolve(undefined)
      })
      
      fileStorage['_currentProjectPath'] = invalidPath
      fileStorage['_currentProjectId'] = 'invalid'
      const result = await fileStorage.deleteMedia('test-media')
      
      // Should return false on error instead of throwing
      expect(result).toBe(false)
    })
  })
})