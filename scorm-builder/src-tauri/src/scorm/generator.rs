use super::package::Resource;
use base64::{engine::general_purpose, Engine as _};
use serde::{Deserialize, Serialize};
use std::io::{Seek, Write};
use std::path::{Path, PathBuf};
use tempfile::TempDir;

#[derive(Debug, Serialize, Deserialize)]
pub struct CourseMetadata {
    pub title: String,
    pub description: String,
    pub project_title: String,
    pub version: Option<String>,
    pub scorm_version: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScormGenerationResult {
    pub success: bool,
    pub file_path: String,
    pub size: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GenerateScormRequest {
    pub project_id: String,
    pub course_content: serde_json::Value,
    pub course_metadata: CourseMetadata,
    #[serde(default)]
    pub media_files: Vec<MediaFile>,
    #[serde(default)]
    pub generated_files: Vec<GeneratedFile>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GeneratedFile {
    pub path: String,
    pub content: String,
    pub is_binary: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MediaFile {
    pub id: String,
    pub file_path: String,
    pub mime_type: String,
}

pub async fn generate_scorm_package(
    request: GenerateScormRequest,
) -> Result<ScormGenerationResult, String> {
    // Create a temporary directory for the SCORM package
    let temp_dir = TempDir::new().map_err(|e| format!("Failed to create temp directory: {e}"))?;

    let output_path = temp_dir.path().join(format!(
        "{}.zip",
        sanitize_filename(&request.course_metadata.title)
    ));

    let mut resources = Vec::new();
    let mut manifest_content: Option<String> = None;

    // Guard: Ensure JavaScript always provides generated files
    if request.generated_files.is_empty() {
        return Err(
            "No generated files provided. SCORM generation must be done through JavaScript."
                .to_string(),
        );
    }

    // Process the files generated by JavaScript
    for gen_file in &request.generated_files {
        // Check if this is the manifest file
        if gen_file.path == "imsmanifest.xml" {
            manifest_content = Some(gen_file.content.clone());
        }

        if gen_file.is_binary {
            // For binary files, decode from base64
            let content = general_purpose::STANDARD
                .decode(&gen_file.content)
                .map_err(|e| format!("Failed to decode base64 for {}: {}", gen_file.path, e))?;
            resources.push(Resource {
                path: gen_file.path.clone(),
                content,
            });
        } else {
            // For text files, use as-is
            resources.push(Resource {
                path: gen_file.path.clone(),
                content: gen_file.content.as_bytes().to_vec(),
            });
        }
    }

    // Create media extension map that will be passed to collect_media_resources
    let mut media_extension_map: std::collections::HashMap<String, String> =
        std::collections::HashMap::new();

    // Populate the map from media_files in the request
    for media_file in &request.media_files {
        // Extract extension from file_path (e.g., "media/image-1.svg" -> "svg")
        if let Some(dot_pos) = media_file.file_path.rfind('.') {
            let extension = &media_file.file_path[dot_pos..]; // Includes the dot
            media_extension_map.insert(media_file.id.clone(), extension.to_string());
        }
    }

    // Always collect media resources from disk
    let media_resources = collect_media_resources(
        &request.project_id,
        &request.course_content,
        &media_extension_map,
    )
    .await?;
    resources.extend(media_resources);

    // Create SCORM package using streaming for media files
    use super::package::{create_scorm_package_streaming, StreamableResource};

    // Get the base path for the project media
    let base_path = dirs::document_dir()
        .ok_or_else(|| "Could not find documents directory".to_string())?
        .join("SCORM Projects")
        .join(&request.project_id)
        .join("media");

    // Collect streamable resources for large media files
    let mut streamable_resources: Vec<StreamableResource> = Vec::new();

    // Check which media files exist on disk and can be streamed
    let media_ids: std::collections::HashSet<String> =
        extract_all_media_ids(&request.course_content);

    println!(
        "[SCORM] Found {} media IDs in course content",
        media_ids.len()
    );
    println!("[SCORM] Media IDs: {media_ids:?}");

    // List all files in the media directory to debug
    if base_path.exists() {
        println!("[SCORM] Media directory exists: {}", base_path.display());
        if let Ok(entries) = std::fs::read_dir(&base_path) {
            println!("[SCORM] Files in media directory:");
            for entry in entries {
                if let Ok(entry) = entry {
                    println!("[SCORM]   - {}", entry.file_name().to_string_lossy());
                }
            }
        }
    } else {
        println!(
            "[SCORM] WARNING: Media directory does not exist: {}",
            base_path.display()
        );
    }

    println!("[SCORM] Media extension map: {media_extension_map:?}");

    // First, add all media from course content
    for media_id in &media_ids {
        let (extension, is_large) = if let Some(ext) = media_extension_map.get(media_id) {
            // Use the extension provided by JavaScript
            let is_large_file = match ext.as_str() {
                ".svg" => false, // SVG files are text, usually small
                ".vtt" => false, // Caption files are text, always small
                _ => true,       // Most image/audio/video files should be streamed
            };
            (ext.as_str(), is_large_file)
        } else if media_id.starts_with("audio-") {
            (".mp3", true) // Audio files are usually large
        } else if media_id.starts_with("video-") {
            (".mp4", true) // Video files are usually large
        } else if media_id.starts_with("image-") && !media_id.contains("logo") {
            // Fallback: Check the actual file to determine extension
            let jpg_path = base_path.join(format!("{media_id}.bin"));
            if jpg_path.exists() {
                (".jpg", true) // Large images should be streamed
            } else {
                (".png", false) // SVGs and small images are already in resources
            }
        } else if media_id.starts_with("caption-") {
            (".vtt", false) // Caption files are small, add to resources
        } else {
            continue; // Skip unknown types
        };

        if is_large {
            let file_path = base_path.join(format!("{media_id}.bin"));
            if file_path.exists() {
                streamable_resources.push(StreamableResource {
                    zip_path: format!("media/{media_id}{extension}"),
                    file_path: file_path.clone(),
                });
                println!(
                    "[SCORM] Added streamable resource: {} -> media/{}{}",
                    file_path.display(),
                    media_id,
                    extension
                );
            } else {
                println!(
                    "[SCORM] WARNING: Media file not found: {}",
                    file_path.display()
                );
            }
        }
    }

    // Additionally, scan the media directory for all audio and caption files
    // This ensures we don't miss any media that wasn't properly referenced
    if base_path.exists() {
        if let Ok(entries) = std::fs::read_dir(&base_path) {
            for entry in entries {
                if let Ok(entry) = entry {
                    let file_name = entry.file_name();
                    let file_name_str = file_name.to_string_lossy();

                    // Check if it's a .bin file (media data)
                    if file_name_str.ends_with(".bin") {
                        let media_id = file_name_str.trim_end_matches(".bin");

                        // Skip if we already processed this media
                        if media_ids.contains(media_id) {
                            continue;
                        }

                        // Determine file type and extension
                        let (extension, should_stream) =
                            if let Some(ext) = media_extension_map.get(media_id) {
                                // Use the extension provided by JavaScript
                                let is_large_file = match ext.as_str() {
                                    ".svg" => false, // SVG files are text, usually small
                                    ".vtt" => false, // Caption files are text, always small
                                    _ => true, // Most image/audio/video files should be streamed
                                };
                                (ext.as_str(), is_large_file)
                            } else if media_id.starts_with("audio-") {
                                (".mp3", true)
                            } else if media_id.starts_with("caption-") {
                                (".vtt", false)
                            } else if media_id.starts_with("image-") {
                                (".jpg", true)
                            } else if media_id.starts_with("video-") {
                                (".mp4", true)
                            } else {
                                continue;
                            };

                        if should_stream {
                            let file_path = entry.path();
                            streamable_resources.push(StreamableResource {
                                zip_path: format!("media/{media_id}{extension}"),
                                file_path: file_path.clone(),
                            });
                            println!(
                                "[SCORM] Added missing media from directory: {} -> media/{}{}",
                                file_path.display(),
                                media_id,
                                extension
                            );
                        }
                    }
                }
            }
        }
    }

    // Ensure we have a manifest
    let manifest = manifest_content.ok_or_else(|| "No manifest content available".to_string())?;

    // For streaming, we don't need separate HTML content since it's in resources
    let empty_html = String::new();

    create_scorm_package_streaming(
        &manifest,
        &empty_html,
        &resources,
        &streamable_resources,
        &output_path,
    )?;

    // Get file size
    let metadata =
        std::fs::metadata(&output_path).map_err(|e| format!("Failed to get file metadata: {e}"))?;

    // Move file to permanent location
    let final_path = get_scorm_output_path(&request.course_metadata.title)?;
    std::fs::rename(&output_path, &final_path)
        .map_err(|e| format!("Failed to move SCORM package: {e}"))?;

    Ok(ScormGenerationResult {
        success: true,
        file_path: final_path.to_string_lossy().to_string(),
        size: metadata.len(),
    })
}

fn sanitize_filename(name: &str) -> String {
    name.chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '-' || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect()
}

fn get_file_extension(mime_type: &str) -> String {
    match mime_type {
        "image/jpeg" => ".jpg",
        "image/png" => ".png",
        "image/gif" => ".gif",
        "image/webp" => ".webp",
        "video/mp4" => ".mp4",
        "video/webm" => ".webm",
        "audio/mpeg" => ".mp3",
        "audio/wav" => ".wav",
        "audio/ogg" => ".ogg",
        "text/vtt" => ".vtt",
        _ => "",
    }
    .to_string()
}

// Removed collect_static_resources - no longer needed since we only use JavaScript-generated files

fn extract_all_media_ids(course_content: &serde_json::Value) -> std::collections::HashSet<String> {
    let mut media_ids = std::collections::HashSet::new();

    // Helper function to extract media IDs from a page
    fn extract_from_page(
        page: &serde_json::Value,
        media_ids: &mut std::collections::HashSet<String>,
    ) {
        if let Some(audio_id) = page.get("audioId").and_then(|v| v.as_str()) {
            media_ids.insert(audio_id.to_string());
        }
        if let Some(caption_id) = page.get("captionId").and_then(|v| v.as_str()) {
            media_ids.insert(caption_id.to_string());
        }
        if let Some(media_array) = page.get("media").and_then(|v| v.as_array()) {
            for media in media_array {
                if let Some(id) = media.get("id").and_then(|v| v.as_str()) {
                    media_ids.insert(id.to_string());
                }
            }
        }
    }

    // Extract from welcome page
    if let Some(welcome) = course_content.get("welcomePage") {
        extract_from_page(welcome, &mut media_ids);
    }

    // Extract from objectives page
    if let Some(objectives) = course_content.get("learningObjectivesPage") {
        extract_from_page(objectives, &mut media_ids);
    }

    // Extract from topics
    if let Some(topics) = course_content.get("topics").and_then(|v| v.as_array()) {
        for topic in topics {
            extract_from_page(topic, &mut media_ids);
        }
    }

    media_ids
}

fn get_scorm_output_path(course_title: &str) -> Result<PathBuf, String> {
    let downloads_dir =
        dirs::download_dir().ok_or_else(|| "Could not find downloads directory".to_string())?;

    let filename = format!("{}_SCORM.zip", sanitize_filename(course_title));
    Ok(downloads_dir.join(filename))
}

// Removed generate_html_content - no longer needed since we only use JavaScript-generated files

async fn collect_media_resources(
    project_id: &str,
    course_content: &serde_json::Value,
    media_extension_map: &std::collections::HashMap<String, String>,
) -> Result<Vec<Resource>, String> {
    let mut resources = Vec::new();

    // Collect media IDs from course content
    let mut media_ids = std::collections::HashSet::new();

    // Helper function to extract media IDs from a page
    fn extract_media_from_page(
        page: &serde_json::Value,
        media_ids: &mut std::collections::HashSet<String>,
    ) {
        if let Some(audio_id) = page.get("audioId").and_then(|v| v.as_str()) {
            media_ids.insert(audio_id.to_string());
        }
        if let Some(caption_id) = page.get("captionId").and_then(|v| v.as_str()) {
            media_ids.insert(caption_id.to_string());
        }
        if let Some(media_array) = page.get("media").and_then(|v| v.as_array()) {
            for media in media_array {
                if let Some(id) = media.get("id").and_then(|v| v.as_str()) {
                    media_ids.insert(id.to_string());
                }
            }
        }
    }

    // Extract from welcome page
    if let Some(welcome) = course_content.get("welcomePage") {
        extract_media_from_page(welcome, &mut media_ids);
    }

    // Extract from objectives page
    if let Some(objectives) = course_content.get("learningObjectivesPage") {
        extract_media_from_page(objectives, &mut media_ids);
    }

    // Extract from topics
    if let Some(topics) = course_content.get("topics").and_then(|v| v.as_array()) {
        for topic in topics {
            extract_media_from_page(topic, &mut media_ids);
        }
    }

    // Load actual media files from disk using media_storage
    use crate::media_storage;

    // Load ALL caption files into resources (they're small text files)
    // Also scan directory to ensure we get all captions
    let base_path = dirs::document_dir()
        .ok_or_else(|| "Could not find documents directory".to_string())?
        .join("SCORM Projects")
        .join(project_id)
        .join("media");

    if base_path.exists() {
        if let Ok(entries) = std::fs::read_dir(&base_path) {
            for entry in entries {
                if let Ok(entry) = entry {
                    let file_name = entry.file_name();
                    let file_name_str = file_name.to_string_lossy();

                    // Load all caption files
                    if file_name_str.starts_with("caption-") && file_name_str.ends_with(".bin") {
                        let media_id = file_name_str.trim_end_matches(".bin");

                        match media_storage::get_media(project_id.to_string(), media_id.to_string())
                        {
                            Ok(media_data) => {
                                resources.push(Resource {
                                    path: format!("media/{media_id}.vtt"),
                                    content: media_data.data,
                                });
                                println!("[SCORM] Loaded caption file: {media_id}");
                            }
                            Err(e) => {
                                println!("[SCORM] Warning: Failed to load caption {media_id}: {e}");
                            }
                        }
                    }
                }
            }
        }
    }

    // Also load small images (logos, SVGs) that should be embedded
    for media_id in &media_ids {
        if media_id.starts_with("image-") && media_id.contains("logo") {
            match media_storage::get_media(project_id.to_string(), media_id.to_string()) {
                Ok(media_data) => {
                    // Use extension from JavaScript if available, otherwise detect from magic bytes
                    let extension = if let Some(ext) = media_extension_map.get(media_id) {
                        ext.as_str()
                    } else if media_data.data.len() >= 4 && &media_data.data[0..4] == b"\x89PNG" {
                        ".png"
                    } else if media_data.data.len() >= 5 && &media_data.data[0..5] == b"<?xml" {
                        ".svg"
                    } else {
                        ".jpg"
                    };

                    resources.push(Resource {
                        path: format!("media/{media_id}{extension}"),
                        content: media_data.data,
                    });
                }
                Err(e) => {
                    println!("[SCORM] Warning: Failed to load media {media_id}: {e}");
                }
            }
        }
    }

    Ok(resources)
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[tokio::test]
    async fn test_generate_scorm_package_creates_file() {
        let request = GenerateScormRequest {
            project_id: "test-project-123".to_string(),
            course_content: json!({
                "welcomePage": {
                    "narration": "Welcome to the course"
                },
                "topics": []
            }),
            course_metadata: CourseMetadata {
                title: "Test Course".to_string(),
                description: "A test course".to_string(),
                project_title: "Test Project".to_string(),
                version: None,
                scorm_version: None,
            },
            media_files: vec![],
            generated_files: vec![],
        };

        let result = generate_scorm_package(request).await;

        // This should fail until we implement the function
        assert!(result.is_ok(), "SCORM generation should succeed");

        let scorm_result = result.unwrap();
        assert!(scorm_result.success);
        assert!(!scorm_result.file_path.is_empty());
        assert!(scorm_result.size > 0);
    }

    #[tokio::test]
    async fn test_generate_scorm_includes_media_files() {
        let request = GenerateScormRequest {
            project_id: "test-project-123".to_string(),
            course_content: json!({
                "welcomePage": {
                    "narration": "Welcome",
                    "mediaReferences": [{
                        "id": "image-0",
                        "type": "image",
                        "pageId": "welcome"
                    }],
                    "audioId": "audio-0"
                }
            }),
            course_metadata: CourseMetadata {
                title: "Test Course".to_string(),
                description: "".to_string(),
                project_title: "Test Project".to_string(),
                version: None,
                scorm_version: None,
            },
            media_files: vec![],
            generated_files: vec![],
        };

        let result = generate_scorm_package(request).await;

        // This test verifies that media files are included
        assert!(result.is_ok());
    }
}

// Stream a file directly into a ZIP without loading into memory
pub fn stream_file_to_zip<W: Write + Seek>(
    zip: &mut zip::ZipWriter<W>,
    source_path: &Path,
    zip_path: &str,
) -> Result<(), String> {
    use std::io::copy;

    let file = std::fs::File::open(source_path)
        .map_err(|e| format!("Failed to open file {}: {}", source_path.display(), e))?;

    let options =
        zip::write::FileOptions::default().compression_method(zip::CompressionMethod::Stored); // No compression for media files

    zip.start_file(zip_path, options)
        .map_err(|e| format!("Failed to start file in ZIP: {e}"))?;

    let mut reader = std::io::BufReader::new(file);
    copy(&mut reader, zip).map_err(|e| format!("Failed to stream file to ZIP: {e}"))?;

    Ok(())
}

#[cfg(test)]
#[path = "generator_test.rs"]
mod generator_tests;
