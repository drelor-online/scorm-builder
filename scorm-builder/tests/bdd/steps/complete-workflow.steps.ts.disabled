import { Given, When, Then } from '@cucumber/cucumber'
import { expect } from '@playwright/test'
import { World } from '../support/world'

Given('I have a clean browser state', async function (this: World) {
  // Clear any stored data
  await this.page.evaluate(() => {
    localStorage.clear()
    sessionStorage.clear()
  })
  
  // Clear cookies
  await this.page.context().clearCookies()
})

Given('the application is running at {string}', async function (this: World, url: string) {
  // Store the base URL for later use
  this.baseUrl = url
})

Given('I navigate to the SCORM Builder application', async function (this: World) {
  const url = this.baseUrl || 'http://localhost:1420'
  await this.page.goto(url)
  
  // Wait for the app to load - might show storage error or dashboard
  await this.page.waitForLoadState('networkidle')
})

When('I enter the following course configuration:', async function (this: World, dataTable) {
  const config = dataTable.rowsHash()
  
  // Enter title
  if (config.Title) {
    await this.page.fill('[data-testid="course-title-input"]', config.Title)
  }
  
  // Set difficulty
  if (config.Difficulty) {
    await this.page.click(`[data-testid="difficulty-${config.Difficulty}"]`)
  }
  
  // Select template
  if (config.Template) {
    await this.page.selectOption('[data-testid="template-select"]', config.Template)
  }
})

Then('I should see the course preview update', async function (this: World) {
  // Wait for preview to update
  await this.page.waitForTimeout(500)
  
  // Check if preview section exists and has content
  const preview = await this.page.locator('[data-testid="course-preview"]')
  await expect(preview).toBeVisible()
})

Then('I should be on the {string} step', async function (this: World, stepName: string) {
  // Map step names to data-testid or other identifiers
  const stepMap: Record<string, string> = {
    'AI Prompt Generator': '[data-testid="ai-prompt-step"]',
    'JSON Import Validator': '[data-testid="json-validator-step"]',
    'Media Enhancement Wizard': '[data-testid="media-wizard-step"]',
    'Audio Narration Wizard': '[data-testid="audio-wizard-step"]',
    'Activities Editor': '[data-testid="activities-editor-step"]',
    'SCORM Package Builder': '[data-testid="scorm-builder-step"]'
  }
  
  const selector = stepMap[stepName] || `text=${stepName}`
  await expect(this.page.locator(selector)).toBeVisible({ timeout: 10000 })
})

Then('I should see the generated prompt containing:', async function (this: World, dataTable) {
  const expectedElements = dataTable.raw().flat()
  const promptTextarea = await this.page.locator('[data-testid="ai-prompt-textarea"]')
  const promptText = await promptTextarea.textContent()
  
  for (const element of expectedElements) {
    expect(promptText).toContain(element)
  }
})

When('I copy the AI prompt', async function (this: World) {
  await this.page.click('[data-testid="copy-prompt-button"]')
})

Then('I should see a success message {string}', async function (this: World, message: string) {
  await expect(this.page.locator(`text=${message}`)).toBeVisible()
})

When('I paste the following JSON response:', async function (this: World, jsonString: string) {
  const jsonTextarea = await this.page.locator('[data-testid="json-input-textarea"]')
  await jsonTextarea.fill(jsonString)
})

When('I click the {string} button', async function (this: World, buttonText: string) {
  await this.page.click(`button:has-text("${buttonText}")`)
})

Then('I should see {string}', async function (this: World, text: string) {
  await expect(this.page.locator(`text=${text}`)).toBeVisible()
})

Then('I should see tabs for {string}, {string}, and topic pages', async function (this: World, tab1: string, tab2: string) {
  await expect(this.page.locator(`[role="tab"]:has-text("${tab1}")`)).toBeVisible()
  await expect(this.page.locator(`[role="tab"]:has-text("${tab2}")`)).toBeVisible()
})

When('I click on the {string} tab', async function (this: World, tabName: string) {
  await this.page.click(`[role="tab"]:has-text("${tabName}")`)
})

When('I search for images with keyword {string}', async function (this: World, keyword: string) {
  await this.page.fill('[data-testid="image-search-input"]', keyword)
  await this.page.click('[data-testid="search-images-button"]')
})

When('I select the first image from search results', async function (this: World) {
  await this.page.waitForSelector('[data-testid="image-result-0"]')
  await this.page.click('[data-testid="image-result-0"]')
})

Then('the welcome page should have an image', async function (this: World) {
  const welcomeImage = await this.page.locator('[data-testid="welcome-page-image"]')
  await expect(welcomeImage).toBeVisible()
})

When('I upload a local image {string}', async function (this: World, fileName: string) {
  // Note: You'll need to have test images in your test fixtures
  const fileInput = await this.page.locator('input[type="file"]')
  await fileInput.setInputFiles(`./tests/fixtures/${fileName}`)
})

Then('the topic should have the uploaded image', async function (this: World) {
  await expect(this.page.locator('[data-testid="topic-image"]')).toBeVisible()
})

Then('I should see the narration text for each page', async function (this: World) {
  await expect(this.page.locator('[data-testid="narration-text"]')).toBeVisible()
})

When('I download the narration text file', async function (this: World) {
  // Start waiting for download before clicking
  const downloadPromise = this.page.waitForEvent('download')
  await this.page.click('[data-testid="download-narration-button"]')
  const download = await downloadPromise
  
  // Store download for later assertions if needed
  this.lastDownload = download
})

Then('a text file should be downloaded', async function (this: World) {
  expect(this.lastDownload).toBeTruthy()
  const fileName = this.lastDownload.suggestedFilename()
  expect(fileName).toMatch(/\.txt$/)
})

When('I upload the audio ZIP file {string}', async function (this: World, fileName: string) {
  const fileInput = await this.page.locator('[data-testid="audio-zip-input"]')
  await fileInput.setInputFiles(`./tests/fixtures/${fileName}`)
})

Then('all pages should show audio players', async function (this: World) {
  const audioPlayers = await this.page.locator('[data-testid="audio-player"]').count()
  expect(audioPlayers).toBeGreaterThan(0)
})

When('I upload the captions ZIP file {string}', async function (this: World, fileName: string) {
  const fileInput = await this.page.locator('[data-testid="captions-zip-input"]')
  await fileInput.setInputFiles(`./tests/fixtures/${fileName}`)
})

Then('all pages should show caption indicators', async function (this: World) {
  const captionIndicators = await this.page.locator('[data-testid="caption-indicator"]').count()
  expect(captionIndicators).toBeGreaterThan(0)
})

Then('I should see the knowledge check for {string}', async function (this: World, topicName: string) {
  await expect(this.page.locator(`text=${topicName}`)).toBeVisible()
  await expect(this.page.locator('[data-testid="knowledge-check-question"]')).toBeVisible()
})

When('I edit the knowledge check question', async function (this: World) {
  await this.page.click('[data-testid="edit-question-button"]')
})

When('I change the question to {string}', async function (this: World, newQuestion: string) {
  await this.page.fill('[data-testid="question-input"]', newQuestion)
})

When('I save the changes', async function (this: World) {
  await this.page.click('[data-testid="save-question-button"]')
})

Then('the knowledge check should be updated', async function (this: World) {
  await expect(this.page.locator('[data-testid="save-success-message"]')).toBeVisible()
})

When('I select SCORM version {string}', async function (this: World, version: string) {
  await this.page.selectOption('[data-testid="scorm-version-select"]', version)
})

When('I set the pass mark to {string}', async function (this: World, passMark: string) {
  const passMarkValue = passMark.replace('%', '')
  await this.page.fill('[data-testid="pass-mark-input"]', passMarkValue)
})

When('I click {string}', async function (this: World, buttonText: string) {
  await this.page.click(`button:has-text("${buttonText}")`)
})

Then('I should see the course preview in an iframe', async function (this: World) {
  await expect(this.page.locator('iframe[data-testid="course-preview-iframe"]')).toBeVisible()
})

When('I close the preview', async function (this: World) {
  await this.page.click('[data-testid="close-preview-button"]')
})

Then('I should see {string}', async function (this: World, text: string) {
  await expect(this.page.locator(`text=${text}`)).toBeVisible()
})

Then('a SCORM package should be downloaded', async function (this: World) {
  // Wait for download if not already captured
  if (!this.lastDownload) {
    this.lastDownload = await this.page.waitForEvent('download', { timeout: 30000 })
  }
  
  expect(this.lastDownload).toBeTruthy()
  const fileName = this.lastDownload.suggestedFilename()
  expect(fileName).toMatch(/\.zip$/)
  expect(fileName).toContain('SCORM')
})